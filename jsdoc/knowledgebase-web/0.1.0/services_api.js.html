<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Wrapper for api, handles all requests and special functions.
 * @module /services/api
 */
import * as jc from 'json-cycle';
import auth from './auth';
import config from '../config.json';
import history from './history';

const {
  VERSION,
  KEYS,
  PORT,
  HOST,
} = config;
const API_BASE_URL = `http://${HOST}:${PORT}/api/v${VERSION}`;
const CACHE_EXPIRY = 8;

/**
 * Appends global headers to outgoing request.
 */
const getHeaders = () => {
  const headers = new Headers();
  headers.append('Content-type', 'application/json');
  if (auth.getToken()) {
    headers.append('Authorization', auth.getToken());
  }
  return headers;
};

/**
 * Sends request to server, appending all global headers and handling responses and errors.
 * @param {string} endpoint - URL endpoint
 * @param {Object} init - Request properties.
 */
const fetchWithInterceptors = (endpoint, init) => {
  const initWithInterceptors = {
    ...init,
    headers: getHeaders(),
  };
  return fetch(new Request(API_BASE_URL + endpoint, initWithInterceptors))
    .then((response) => {
      if (response.ok) {
        return response.json();
      }
      return Promise.reject(response);
    })
    .catch(error => error.json().then(body => Promise.reject({
      status: error.status,
      body,
    })))
    .catch((error) => {
      if (error.status === 401) {
        let state = {};
        if (auth.isExpired()) {
          state = { timedout: true };
        }
        auth.clearToken();
        if (history.location.pathname !== '/login') {
          history.push({ pathname: '/login', state });
          return Promise.reject('Unauthorized, redirecting...');
        }
        return Promise.reject(error);
      }
      if (error.status === 400) {
        history.push({ pathname: '/query/advanced', state: error });
        return Promise.reject('Invalid Query');
      }
      history.push({ pathname: '/error', state: { status: error.status, body: error.body } });
      return Promise.reject('Unexpected Error, redirecting...');
    });
};

/**
 * Sends PATCH request to api.
 * @param {string} endpoint - URL endpoint.
 * @param {Object} payload - PATCH payload.
 */
const patch = (endpoint, payload) => {
  const init = {
    method: 'PATCH',
    body: JSON.stringify(payload),
  };
  return fetchWithInterceptors(endpoint, init);
};

/**
 * Sends GET request to api.
 * @param {string} endpoint - URL endpoint.
 */
const get = (endpoint) => {
  const init = {
    method: 'GET',
  };
  return fetchWithInterceptors(endpoint, init);
};

/**
 * Sends POST request to api.
 * @param {string} endpoint - URL endpoint.
 * @param {Object} payload - POST payload.
 */
const post = (endpoint, payload) => {
  const init = {
    method: 'POST',
    body: JSON.stringify(payload),
  };

  return fetchWithInterceptors(endpoint, init);
};

/**
 * Sends DELETE request to api.
 * @param {string} endpoint - URL endpoint.
 */
const del = (endpoint) => {
  const init = {
    method: 'DELETE',
  };

  return fetchWithInterceptors(endpoint, init);
};

/**
 * Requests sources from api and loads into localstorage.
 */
const loadSources = () => get('/sources').then((response) => {
  const cycled = jc.retrocycle(response.result);
  const list = [];
  cycled.forEach(source => list.push(source));

  const now = new Date();
  const expiry = new Date(now);
  expiry.setHours(now.getHours() + CACHE_EXPIRY);

  localStorage.setItem(`${KEYS.SOURCES}Expiry`, expiry.getTime());
  localStorage.setItem(KEYS.SOURCES, JSON.stringify(list));

  return Promise.resolve(list);
});

/**
 * Returns all valid sources.
 */
const getSources = () => {
  const sources = localStorage.getItem(KEYS.SOURCES);
  const sourcesExpiry = localStorage.getItem(`${KEYS.SOURCES}Expiry`);
  if (
    !sources || (sources &amp;&amp; sourcesExpiry &amp;&amp; sourcesExpiry &lt; Date.now().valueOf())
  ) {
    return loadSources();
  }
  return Promise.resolve(JSON.parse(sources));
};

/**
 * Requests schema from api and loads into localstorage.
 */
const loadSchema = () => get('/schema').then((response) => {
  const cycled = jc.retrocycle(response.schema);
  const now = new Date();
  const expiry = new Date(now);
  expiry.setHours(now.getHours() + CACHE_EXPIRY);

  const schema = {
    schema: cycled,
    version: VERSION,
  };

  localStorage.setItem(`${KEYS.SCHEMA}Expiry`, expiry.getTime());
  localStorage.setItem(KEYS.SCHEMA, JSON.stringify(schema));

  return Promise.resolve(cycled);
});

/**
 * Returns the database schema.
 */
const getSchema = () => {
  const schema = JSON.parse(localStorage.getItem(KEYS.SCHEMA) || '{}');
  const schemaExpiry = localStorage.getItem(`${KEYS.SCHEMA}Expiry`);
  if (
    !schema
    || (
      schema
      &amp;&amp; schemaExpiry
      &amp;&amp; schemaExpiry &lt; Date.now().valueOf()
    )
    || schema.version !== VERSION
  ) {
    return loadSchema();
  }
  return Promise.resolve(schema.schema);
};

/**
 * Returns the editable properties of target ontology class.
 * @param {string} className - requested class name
 */
const getClass = className => getSchema().then((schema) => {
  const VPropKeys = Object.keys(schema.V.properties);
  const classKey = (Object.keys(schema)
    .find(key => key.toLowerCase() === (className || '').toLowerCase()) || 'Ontology');
  const props = Object.keys(schema[classKey].properties)
    .filter(prop => !VPropKeys.includes(prop))
    .map(prop => (
      {
        ...schema[classKey].properties[prop],
      }));
  return Promise.resolve({ route: schema[classKey].route, properties: props });
});

/**
 * Wrapper for autosearch method.
 * @param {string} endpoint - URL endpoint.
 * @param {string} property - Property to query.
 * @param {string} value - Query input string.
 * @param {number} limit - Limit for number of returned matches.
 */
const autoSearch = (endpoint, property, value, limit) => {
  const results = [];
  for (let i = 0; i &lt; property.length; i += 1) {
    const intResults = get(`/${endpoint}?${property[i]}=~${encodeURIComponent(value)}&amp;limit=${limit}&amp;neighbors=1&amp;@class=!Publication`);
    results.push(intResults);
  }
  return Promise.all(results);
};

/**
 * Updates allColumns list with any new properties from ontologyTerm.
 * @param {Object} ontologyTerm - new node who's properties will be parsed.
 * @param {Array} allColumns - current list of all collected properties.
 * @param {Object} schema - api schema.
 */
const collectOntologyProps = (ontologyTerm, allColumns, schema) => {
  const { properties } = schema[ontologyTerm['@class']];
  const { V } = schema;
  Object.keys(ontologyTerm).forEach((prop) => {
    if (!V.properties[prop] &amp;&amp; prop !== '@class' &amp;&amp; !allColumns.includes(prop)) {
      const endpointProp = properties[prop];
      if (endpointProp &amp;&amp; endpointProp.type === 'link') {
        Object.keys(ontologyTerm[prop]).forEach((nestedProp) => {
          if (
            !V.properties[nestedProp]
            &amp;&amp; !allColumns.includes(`${prop}.${nestedProp}`)
            &amp;&amp; !nestedProp.startsWith('in_')
            &amp;&amp; !nestedProp.startsWith('out_')
            &amp;&amp; !(endpointProp.linkedClass &amp;&amp; nestedProp === '@class')
            &amp;&amp; (properties[nestedProp] || {}).type !== 'link'
          ) {
            allColumns.push(`${prop}.${nestedProp}`);
          }
        });
      } else {
        allColumns.push(prop);
      }
    }
  });
  return allColumns;
};

/**
  * Returns all valid ontology types.
  */
const getOntologies = (schema) => {
  const list = [];
  Object.keys(schema).forEach((key) => {
    if (schema[key].inherits.includes('Ontology')) {
      list.push({ name: key, properties: schema[key].properties, route: schema[key].route });
    }
  });
  return list;
};

/**
  * Returns all valid edge types.
  */
const getEdges = (schema) => {
  const list = [];
  Object.keys(schema).forEach((key) => {
    if (schema[key].inherits.includes('E')) {
      list.push(key);
    }
  });
  return list;
};

export default {
  getEdges,
  getOntologies,
  collectOntologyProps,
  getHeaders,
  getClass,
  getSchema,
  getSources,
  get,
  post,
  delete: del,
  patch,
  autoSearch,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-_App.html">/App</a></li><li><a href="module-_components_AutoSearchComponent.html">/components/AutoSearchComponent</a></li><li><a href="module-_components_DownloadFileComponent.html">/components/DownloadFileComponent</a></li><li><a href="module-_components_GraphActionsNode.html">/components/GraphActionsNode</a></li><li><a href="module-_components_GraphComponent.html">/components/GraphComponent</a></li><li><a href="module-_components_GraphLink.html">/components/GraphLink</a></li><li><a href="module-_components_GraphNode.html">/components/GraphNode</a></li><li><a href="module-_components_NodeDetailComponent.html">/components/NodeDetailComponent</a></li><li><a href="module-_components_NodeFormComponent.html">/components/NodeFormComponent</a></li><li><a href="module-_components_ResourceSelectComponent.html">/components/ResourceSelectComponent</a></li><li><a href="module-_components_TableComponent.html">/components/TableComponent</a></li><li><a href="module-_services_api.html">/services/api</a></li><li><a href="module-_services_auth.html">/services/auth</a></li><li><a href="module-_services_util.html">/services/util</a></li><li><a href="module-_views_AddNodeView.html">/views/AddNodeView</a></li><li><a href="module-_views_AdvancedQueryView.html">/views/AdvancedQueryView</a></li><li><a href="module-_views_DataView.html">/views/DataView</a></li><li><a href="module-_views_EditNodeView.html">/views/EditNodeView</a></li><li><a href="module-_views_ErrorView.html">/views/ErrorView</a></li><li><a href="module-_views_FeedbackView.html">/views/FeedbackView</a></li><li><a href="module-_views_LoginView.html">/views/LoginView</a></li><li><a href="module-_views_NodeDetailView.html">/views/NodeDetailView</a></li><li><a href="module-_views_QueryView.html">/views/QueryView</a></li><li><a href="module-services_history.html">services/history</a></li></ul><h3>Classes</h3><ul><li><a href="module-_App-App.html">App</a></li><li><a href="module-_components_AutoSearchComponent-AutoSearchComponent.html">AutoSearchComponent</a></li><li><a href="module-_components_GraphComponent-GraphComponent.html">GraphComponent</a></li><li><a href="module-_components_GraphNode-GraphNode.html">GraphNode</a></li><li><a href="module-_components_NodeDetailComponent-NodeDetailComponent.html">NodeDetailComponent</a></li><li><a href="module-_components_NodeFormComponent-NodeFormComponent.html">NodeFormComponent</a></li><li><a href="module-_components_TableComponent-TableComponent.html">TableComponent</a></li><li><a href="module-_views_AddNodeView-AddNodeView.html">AddNodeView</a></li><li><a href="module-_views_AdvancedQueryView-AdvancedQueryView.html">AdvancedQueryView</a></li><li><a href="module-_views_DataView-DataView.html">DataView</a></li><li><a href="module-_views_EditNodeView-EditNodeView.html">EditNodeView</a></li><li><a href="module-_views_ErrorView-ErrorView.html">ErrorView</a></li><li><a href="module-_views_LoginView-LoginView.html">LoginView</a></li><li><a href="module-_views_NodeDetailView-NodeDetailView.html">NodeDetailView</a></li><li><a href="module-_views_QueryView-QueryView.html">QueryView</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Aug 17 2018 13:28:05 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
